export type GitHubConfig = {
  pat: string;
  owner: string;
  repo: string;
};

const STORAGE_KEY = "vector_github";
const LABEL_NAME = "vector";
const LABEL_COLOR = "0f0f0f";
const DELAY_MS = 200;

export function loadConfig(): GitHubConfig | null {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (parsed.pat && parsed.owner && parsed.repo) return parsed as GitHubConfig;
    return null;
  } catch {
    return null;
  }
}

export function saveConfig(config: GitHubConfig) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
}

export function clearConfig() {
  localStorage.removeItem(STORAGE_KEY);
}

function headers(pat: string) {
  return {
    "Content-Type": "application/json",
    Authorization: `Bearer ${pat}`,
    Accept: "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
  };
}

function delay(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function ensureLabel(config: GitHubConfig) {
  const { pat, owner, repo } = config;
  const base = `https://api.github.com/repos/${owner}/${repo}`;

  const check = await fetch(`${base}/labels/${LABEL_NAME}`, {
    headers: headers(pat),
  });

  if (check.status === 404) {
    await fetch(`${base}/labels`, {
      method: "POST",
      headers: headers(pat),
      body: JSON.stringify({
        name: LABEL_NAME,
        color: LABEL_COLOR,
        description: "Generated by Vector",
      }),
    });
  }
}

async function createIssue(
  config: GitHubConfig,
  title: string,
  body: string
): Promise<{ html_url: string }> {
  const { pat, owner, repo } = config;
  const res = await fetch(
    `https://api.github.com/repos/${owner}/${repo}/issues`,
    {
      method: "POST",
      headers: headers(pat),
      body: JSON.stringify({ title, body, labels: [LABEL_NAME] }),
    }
  );

  if (res.status === 401) throw new Error("AUTH");
  if (res.status === 404) throw new Error("NOT_FOUND");
  if (!res.ok) throw new Error(`HTTP_${res.status}`);

  return res.json();
}

function buildIssueBody(
  epicName: string,
  subtasks: string[],
  featureName: string,
  arrAtRisk?: number
): string {
  const arr = arrAtRisk
    ? arrAtRisk >= 1_000_000
      ? `$${(arrAtRisk / 1_000_000).toFixed(1)}M`
      : `$${Math.round(arrAtRisk / 1000)}k`
    : null;

  const checklist = subtasks.map((s) => `- [ ] ${s}`).join("\n");

  return [
    `## Context`,
    `Part of the **${featureName}** spec generated by Vector.`,
    arr ? `ARR at risk: ${arr}` : "",
    ``,
    `## Subtasks`,
    checklist || "_No subtasks defined._",
    ``,
    `## Epic`,
    epicName,
    ``,
    `---`,
    `*Generated by [Vector](https://github.com)*`,
  ]
    .filter((l) => l !== null)
    .join("\n");
}

export type ExportStory = {
  epicName: string;
  storyTitle: string;
  subtasks: string[];
};

export type ExportProgress = {
  done: number;
  total: number;
  currentTitle: string;
  repoUrl: string;
};

export async function exportSpec(
  config: GitHubConfig,
  stories: ExportStory[],
  featureName: string,
  arrAtRisk: number | undefined,
  onProgress: (p: ExportProgress) => void
): Promise<string> {
  const repoUrl = `https://github.com/${config.owner}/${config.repo}/issues`;

  await ensureLabel(config);

  for (let i = 0; i < stories.length; i++) {
    const { epicName, storyTitle, subtasks } = stories[i];
    const title = `[${epicName}] ${storyTitle}`;
    const body = buildIssueBody(epicName, subtasks, featureName, arrAtRisk);

    onProgress({ done: i, total: stories.length, currentTitle: title, repoUrl });

    await createIssue(config, title, body);
    if (i < stories.length - 1) await delay(DELAY_MS);
  }

  onProgress({
    done: stories.length,
    total: stories.length,
    currentTitle: "",
    repoUrl,
  });

  return repoUrl;
}
